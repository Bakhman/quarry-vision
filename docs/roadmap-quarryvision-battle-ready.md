# QuarryVision — Roadmap доведения до боевого состояния (фокус: номера/скорость)

Версия: 2026-01-08  
Источник требований: загруженные PDF «Глубокий анализ…» и «Сравнение плана…».

---

## 1) Цели и критерии «боевое» (Definition of Done)

### 1.1 Производительность
- Режим по умолчанию (адаптивный) должен обрабатывать ~2.5-минутное видео **не дольше 5–6 минут**.
- Обработка должна быть **не медленнее реального времени** (в идеале 0.3–0.7× длительности видео) на типовой машине без выделенного ускорителя.

### 1.2 Качество распознавания номера
- Распознавать **≥90% номеров, читаемых человеком** на эталонных видео.
- Уменьшить число ложных «валидных» номеров (пример типа `O245BO`) за счёт улучшения выбора кандидата и нормализации.

### 1.3 Устойчивость продукта
- При сбоях/провалах OCR (Optical Character Recognition, оптическое распознавание символов) продукт всё равно выдаёт:
  - события (timestamps),
  - рейсы (по времени),
  - понятный статус обработки в UI (User Interface, пользовательский интерфейс).

---

## 2) Принципиальное решение (архитектурный вектор)

### 2.1 Базовый тезис
Нельзя достигнуть near-real-time, если в «горячем цикле» идут тысячи вызовов OCR (Optical Character Recognition, оптическое распознавание символов) по десяткам ROI (Region of Interest, область интереса) на событие.

### 2.2 Целевой конвейер
1) Детекция событий: быстро, без OCR (Optical Character Recognition, оптическое распознавание символов).  
2) Сегментация рейсов: по времени (как минимальный устойчивый результат).  
3) Определение номера рейса (PlateResolver): читать номер **редко**, подтверждать быстро (early stop).  
4) Запись результатов в DB (Database, база данных) и отображение в UI (User Interface, пользовательский интерфейс).

---

## 3) Правила работы в этом чате (операционные)
- GitHub — источник истины; изменения — маленькими шагами.
- Каждое изменение — отдельная ветка и PR (Pull Request, запрос на слияние).
- Обсуждение только по конкретным классам/файлам через diff/фрагменты/логи.
- Никаких предположений: если файла/фрагмента нет — он считается «не предоставлен».

---

## 4) Артефакты контроля (обязательные)
- `docs/perf-baseline.md` — базовые метрики (до оптимизаций) на эталонных видео.
- `docs/perf-after-PR-*.md` — метрики после каждого ключевого PR (Pull Request, запрос на слияние).
- `docs/roadmap-quarryvision-battle-ready.md` — этот файл (обновляется при изменении плана).
- Эталонные видео: минимум 2:
  - A) короткое (~2–3 мин, «типовое»),
  - B) сложное («грязь/сумерки/блики/наклон»).

---

## 5) План работ по этапам (PR-ориентированный)

> Нумерация PR — логическая. Фактические номера в GitHub могут отличаться.

### PR-0 — Benchmark + PERF/TRACE (инструментирование)
**Цель:** превратить «медленно» в измеряемые числа.  
**Изменения:**
- Добавить таймеры по стадиям: decode / detect / ocr / db.
- Добавить счётчики: framesDecoded, framesProcessed, eventsFound, roiScans, ocrCalls.
- Добавить итоговую строку `PERF {...}` (JSON-подобная) в лог + сохранить в `docs/perf-baseline.md`.

**Acceptance (проверка):**
- Один прогон эталонного видео A даёт:
  - общее время,
  - `ocrCalls`,
  - среднее время одного OCR (Optical Character Recognition, оптическое распознавание символов) вызова,
  - топ-1 узкое место (что съело >60% времени).

---

### PR-1 — Decouple: убрать OCR из горячего цикла детекции событий
**Цель:** события и рейсы по времени должны считаться быстро независимо от OCR.  
**Изменения:**
- Детектор событий пишет только timestamps (+ опционально индексы кадров/anchor-кадры).
- OCR (Optical Character Recognition, оптическое распознавание символов) переносится во второй этап (после детекции / после сегментации).

**Acceptance:**
- Прогон эталонного видео A: стадия детекции событий ускоряется кратно.
- Даже при отключённом OCR продукт показывает события/рейсы по времени.

---

### PR-2 — PlateResolver v1: «читать номер на рейс», early stop
**Цель:** радикально уменьшить число OCR-вызовов.  
**Алгоритм (v1):**
- Сначала строим рейсы по времени (минимальная сегментация).
- Для каждого рейса берем окна времени:
  - start: `[start-2s .. start+6s]`,
  - end: `[end-6s .. end+2s]`.
- Дискретизация: 2–4 fps (frames per second, кадров в секунду) (не все кадры).
- На кадр берём 1–2 лучших ROI (Region of Interest, область интереса) кандидата.
- OCR (Optical Character Recognition, оптическое распознавание символов) до подтверждения:
  - если один номер встретился 2 раза → stop,
  - если встретились 2 разных «валидных» → пометить ambiguous / оставить undefined.

**Побочный эффект (нужный):**
- Backfill: после определения номера рейса можно заполнить `events.plate` этим номером (или хранить отдельно `trip.plate` — решается в PR-4/PR-5).

**Acceptance:**
- На эталонном видео A: `ocrCalls` падает минимум в 5–10 раз относительно baseline.
- Время обработки приближается к реальному времени (или становится существенно лучше baseline).

---

### PR-3 — PlateCandidateFinder: быстрая локализация таблички (без ML)
**Цель:** перестать искать номер «сеткой ROI», перейти к 1–3 кандидатам на кадр.  
**Реализация (OpenCV-конвейер, без нейросетей):**
- grayscale → blur → Canny → findContours
- фильтры прямоугольников: площадь, aspect ratio, edge density
- top-k = 3 кандидата

**Acceptance:**
- `roiScans` снижается радикально.
- На видео A и B: кандидаты стабильны (не прыгают хаотично), OCR (Optical Character Recognition, оптическое распознавание символов) вызывается только на top-k.

---

### PR-4 — Quality pack: выбор кандидата, нормализация, PSM-эксперименты
**Цель:** уменьшить ложные «валидные» номера и стабилизировать результат.  
**Изменения:**
- Проверить tie-break (разрешение ничьих) при равных score (случаи типа `O245BO` vs `BE8624`).
- Усилить нормализацию (карта путаницы символов) и правила валидации.
- Эксперименты с PSM (Page Segmentation Mode, режим сегментации страницы Tesseract):
  - зафиксировать, какие режимы дают лучший результат на ваших данных,
  - добавить конфиг и тест.

**Acceptance:**
- На видео B уменьшается число ложных номеров (сравнение с ручной разметкой).
- Повышается процент рейсов с корректным номером без роста ложных срабатываний.

---

### PR-5 — DB + Trips: хранение результата по рейсу и пересчёт
**Цель:** перестать зависеть от «MIN_PLATE_VOTES=2 на уровне событий» и сделать продуктовую модель устойчивой.  
**Изменения (варианты, выбираем один):**
- A) Добавить `trips` (если ещё нет) и хранить `trip.plate`, `trip.plate_votes`, `trip.plate_confidence`.
- B) Если `trips` уже есть — расширить схему и заполнение.
- События могут хранить:
  - либо «сырой plate как наблюдение»,
  - либо backfill `events.plate = trip.plate` (и отдельно хранить наблюдения/кандидаты — опционально).

**Acceptance:**
- UI (User Interface, пользовательский интерфейс) больше не ломается на ситуации «номер был один раз».
- Уменьшается доля `undefined` рейсов без увеличения ошибок.

---

### PR-6 — UI + Release: доведение до оператора и выпуск
**Цель:** сделать результат пригодным для реальной эксплуатации.  
**Изменения:**
- Reports:
  - показывать номер рейса,
  - фильтр по номеру,
  - экспорт CSV (Comma-Separated Values, значения, разделённые запятыми).
- Queue:
  - статусы обработки,
  - прогресс (хотя бы по стадиям: detecting / resolving plates / writing db).
- Финальный прогон A и B, запись метрик и вывод «готово/не готово» по DoD.

**Acceptance:**
- Выпуск версии (например v1.3.0 — если соответствует вашей версии ветвления).
- Документ `docs/perf-after-PR-6.md` содержит подтверждение целевых метрик.

---

## 6) Опциональный трек (после PR-3/PR-4): ML-локализация номера
Если классический PlateCandidateFinder не обеспечивает качество/устойчивость:
- добавить детектор номера на базе модели (например YOLO-подобная) через ONNX Runtime (Open Neural Network Exchange Runtime, рантайм нейросетевых моделей),
- OCR (Optical Character Recognition, оптическое распознавание символов) только по bbox (bounding box, ограничивающий прямоугольник).

---

## 7) Риски и контрольные вопросы (чтобы не “утонуть”)
- Если после PR-2 `ocrCalls` всё ещё тысячи → early stop/окна/дискретизация настроены неверно.
- Если после PR-3 качество сильно падает → фильтры кандидатов слишком жёсткие (нужно расширить допустимые ROI).
- Если после PR-4 растёт ложноположительная идентификация → нормализация слишком “агрессивная”, нужны дополнительные проверки/конфиденс (confidence).

---

## 8) Статус выполнения (чеклист)
- [ ] PR-0: perf-baseline собран
- [ ] PR-1: OCR вынесен из горячего цикла
- [ ] PR-2: PlateResolver v1 + early stop
- [ ] PR-3: PlateCandidateFinder без ML
- [ ] PR-4: Quality pack (tie-break/нормализация/PSM)
- [ ] PR-5: Trips/DB модель и пересчёт
- [ ] PR-6: UI + Release + финальные метрики
- [ ] DoD выполнен на видео A и B
---

## 9) Соглашения по веткам, PR и коммитам (чтобы не расползалось)

### 9.1 Именование веток
Формат: `<area>/<short-topic>[-<n>]`

Рекомендуемые `area`:
- `perf/` — измерения, логи, профилирование
- `refactor/` — реорганизация пайплайна, декомпозиция
- `ocr/` — распознавание, нормализация, PSM (Page Segmentation Mode, режим сегментации страницы)
- `ui/` — интерфейс
- `db/` — миграции и схемы

Примеры:
- `perf/trace-processing`
- `refactor/decouple-ocr-from-detect`
- `ocr/plate-resolver-v1`
- `ocr/plate-candidate-finder`
- `ui/reports-plate-filter-export`

### 9.2 Правила PR (Pull Request, запрос на слияние)
Каждый PR должен содержать:
- Краткую цель (1–2 предложения).
- Список изменений (bullets).
- Как проверить (команды + ожидаемый результат).
- Метрики “до/после” если PR влияет на скорость/качество (ссылка на `docs/perf-*.md`).
- Ограничение по размеру: один PR — одна тема. Если тема разрослась — делим.

Шаблон заголовка PR:
- `PERF: ...`
- `REFACTOR: ...`
- `OCR: ...`
- `DB: ...`
- `UI: ...`

### 9.3 Коммиты
Стиль (минимально строгий):
- `PERF: add trace metrics for OCR`
- `REFACTOR: decouple OCR from event detection`
- `OCR: add PlateResolver v1 with early-stop`
- `DB: add column trip_plate_confidence`
- `UI: show trip plate in reports`

### 9.4 Файлы-артефакты
- `docs/perf-baseline.md` — фиксируем базовые замеры (до оптимизаций).
- `docs/perf-after-PR-<N>.md` — замеры после ключевых PR.
- Любые “одноразовые” логи/дампы — в `.gitignore` или в `docs/_artifacts/` (если нужно хранить в репозитории).


